# Variáveis de Ambiente para a Stack Chatwoot
# -----------------------------------------------------

# Ambiente Rails/Node
RAILS_ENV=production
NODE_ENV=production

# Domínio do Chatwoot
# O host (apenas o domínio, sem https://) será usado para os labels do Traefik.
# Exemplo: chatwoot.maikones.com
FRONTEND_URL_HOST="chatwoot.maikones.com"
FRONTEND_URL="https://chatwoot.maikones.com"

# Nome da Instalação
INSTALLATION_NAME="abrangenet"

# Configurações básicas
DEFAULT_LOCALE="pt_BR"
TZ="America/Sao_Paulo"
FORCE_SSL="true"
ENABLE_ACCOUNT_SIGNUP="false" # Defina como "true" se quiser permitir registro de novas contas

# Chave Secreta - MUITO IMPORTANTE! Gere uma nova se esta não for única.
# Pode usar 'bundle exec rails secret' dentro do container do Chatwoot para gerar uma nova.
SECRET_KEY_BASE="0848ba45f7ae9c21f5d9c0b36fccdd5f"

# -----------------------------------------------------
# Configurações do Banco de Dados (PostgreSQL)
# -----------------------------------------------------
POSTGRES_HOST="postgres" # Nome do serviço do PostgreSQL no docker-compose.yml
POSTGRES_PORT="5432"
POSTGRES_DATABASE="chatwoot" # Nome do seu banco de dados
POSTGRES_USERNAME="postgres" # Seu usuário do PostgreSQL
POSTGRES_PASSWORD="ff2eb3953e0f25f5f8b9e5c444f8e402" # Sua senha do PostgreSQL

# -----------------------------------------------------
# Configurações do Redis
# -----------------------------------------------------
REDIS_URL="redis://redis:6379" # Nome do serviço do Redis no docker-compose.yml

# -----------------------------------------------------
# Configurações de Armazenamento (ActiveStorage)
# -----------------------------------------------------
# Use "local" para armazenamento local (padrão)
# Para MinIO/S3-compatible, você precisaria de mais variáveis:
ACTIVE_STORAGE_SERVICE="local"
# STORAGE_BUCKET_NAME="chatwoot"
# STORAGE_ACCESS_KEY_ID="ACCESS_KEY_MINIO"
# STORAGE_SECRET_ACCESS_KEY="SECRET_KEY_MINIO"
# STORAGE_REGION="eu-south"
# STORAGE_ENDPOINT="https://s3.DOMINIO.COM"
# STORAGE_FORCE_PATH_STYLE="true"

# -----------------------------------------------------
# Configurações de E-mail (SMTP)
# -----------------------------------------------------
MAILER_SENDER_EMAIL="ia@maikones.com <ia@maikones.com>"
SMTP_DOMAIN="maikones.com"
SMTP_ADDRESS="smtp.hostinger"
SMTP_PORT="587"
SMTP_SSL="false"
SMTP_USERNAME="ia@maikones.com"
SMTP_PASSWORD="@Mkns9767"
SMTP_AUTHENTICATION="login"
SMTP_ENABLE_STARTTLS_AUTO="true"
SMTP_OPENSSL_VERIFY_MODE="peer" # Ou "none" se tiver problemas (menos seguro)
MAILER_INBOUND_EMAIL_DOMAIN="ia@maikones.com"

# -----------------------------------------------------
# Configurações de Desempenho
# -----------------------------------------------------
SIDEKIQ_CONCURRENCY="10"
RACK_TIMEOUT_SERVICE_TIMEOUT="0"
RAILS_MAX_THREADS="5"
WEB_CONCURRENCY="2"
ENABLE_RACK_ATTACK="false"

# -----------------------------------------------------
# AGENT_ONLY_MINE (MANTEMOS AQUI PARA COMPATIBILIDADE, mas o código é injetado no Dockerfile)
# -----------------------------------------------------
AGENT_ONLY_MINE="true"
# O conteúdo real do initializer AGENT_ONLY_MINE é grande para o .env,
# ele será injetado diretamente no command do docker-compose.yml conforme a estratégia.
# Este é um placeholder para a variável AGENT_ONLY_MINE,
# e o conteúdo completo virá via `printf` no comando do docker-compose.yml
AGENT_ONLY_MINE_INIT='# AGENT_ONLY_MINE initializer
# Restringe agente a ver somente conversas atribuídas a ele
begin
  if ENV['"'"'AGENT_ONLY_MINE'"'"'].to_s == '"'"'true'"'"'
    mod = Module.new do
      def self.prepended(base)
        base.before_action :__agent_only_mine_filter__
      end
      private
      def __agent_only_mine_filter__
        user = (defined?(current_user) ? current_user : nil) || (defined?(Current) ? Current.user : nil)
        account = (defined?(current_account) ? current_account : nil) || (defined?(Current) ? Current.account : nil)
        return unless user && account
        # só aplica para agentes (admins continuam vendo tudo)
        if (user.respond_to?(:agent?) && user.agent?) || (user.respond_to?(:role) && user.role.to_s == '"'"'agent'"'"')
          if !params[:id] # listagem
            params[:assignee_id] = user.id
            # opcional: forçar status open; descomente se quiser
            # params[:status] ||= '"'"'open'"'"'
          else # show/update
            begin
              conv = account.conversations.find_by(id: params[:id])
              if conv && conv.assignee_id && conv.assignee_id != user.id
                render json: { error: '"'"'Forbidden'"'"' }, status: :forbidden
              end
            rescue => e
              Rails.logger.error("[AGENT_ONLY_MINE] show-check error: #{e.message}")
            end
          end
        end
      end
    end
    if defined?(Api::V1::Accounts::ConversationsController)
      Api::V1::Accounts::ConversationsController.prepend(mod)
      Rails.logger.info(''"'"'[AGENT_ONLY_MINE] ConversationsController patch ativo'""'"')
    else
      Rails.logger.warn(''"'"'[AGENT_ONLY_MINE] ConversationsController não encontrado nesta build'""'"')
    end
  end
rescue => e
  Rails.logger.error("[AGENT_ONLY_MINE] initializer error: #{e.message}")
end'

# -----------------------------------------------------
# APIs Externas (Evolution API, UAZAPI) - se necessário para webhooks, etc.
# -----------------------------------------------------
# Estas URLs podem ser usadas no código Rails se precisar de defaults globais.
# No seu caso, o Campaign model já as define, então estas são mais para referência ou se o Rails precisar.
# EVOLUTION_API_URL="http://evolution-api:8080"
# UAZAPI_API_URL="https://api.uazapi.com"
